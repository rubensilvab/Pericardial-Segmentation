# -*- coding: utf-8 -*-
"""gaussian_calc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jSUtOlGK8GvZi_cq5m5Q9oQcIPC5HNWs
"""


import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import random

def noisy_gaussian(image,mask):
  
      bth,depth,row,col,ch= image.shape
      
      shape=row,col
      
      points_mask = np.argwhere(mask == 1)
      #print(points_mask)
      #ver onde fica o coraçao em 3d
      max_z=np.max(points_mask[:,1])
      min_z=np.min(points_mask[:,1])
      #print(min_z,max_z)
      slices_w_peri=max_z-min_z
      div=slices_w_peri//3
      middle_part=[min_z+div,min_z+2*div]
      #print('middle',middle_part)
      indexes_middle = np.where((points_mask[:, 1] >= middle_part[0]) & (points_mask[:, 1] <= middle_part[1]))
      points_middle=points_mask[indexes_middle]
      #print(points_middle)
      max_x,min_x,max_y,min_y=np.max(points_middle[:,2]),np.min(points_middle[:,2]),np.max(points_middle[:,3]),np.min(points_middle[:,3])
      middle_x,middle_y=int(np.mean([max_x,min_x])),int(np.mean([max_y,min_y]))  
      indexes_mid = np.where((points_middle[:, 1] ==middle_part[0]) &(points_middle[:, 2] >min_x) &(points_middle[:, 2] <max_x) & (points_middle[:, 3]>min_y)& (points_middle[:, 3]<max_y))
      
      points_calc=points_middle[indexes_mid]
     
      points_calc=np.squeeze(points_calc)
      #print(points_calc)
      
      image,mask=np.squeeze(image),np.squeeze(mask)
      
      #Variaçao aleatoria de altura(um pouco)
      sli_add_after=random.randint(0,7)
      sli_add_before=random.randint(0,7)
      
      slices_before,slices_after=image[0:middle_part[0]-sli_add_before],image[middle_part[1]+sli_add_after:]
      #print(slices_after.shape,slices_before.shape)
      
      n_middle=middle_part[1]-middle_part[0]+sli_add_after+sli_add_before
      
      points_calc=np.array([points_calc[:,2],points_calc[:,3]]).reshape(-1,2)
      #print(points_calc.shape) 
     
      index=random.randint(0,len(points_calc)-1)       
      random_n=random.randint(1,2)
    
      if random_n==1:
               
            index2=random.randint(0,len(points_calc)-1)
            gauss2=[makeGaussian(row,center=points_calc[index2])*mask[s+middle_part[0]-sli_add_before] for s in range(n_middle) ]
            gauss2=np.concatenate(gauss2,axis=0).reshape(-1,row,row)
            
            
      else:
            gauss2=0
            
      gauss=[makeGaussian(row,center=points_calc[index])*mask[s+middle_part[0]-sli_add_before] for s in range(n_middle)]
      gauss=np.concatenate(gauss,axis=0).reshape(-1,row,row)
    
      gauss_total=gauss + gauss2
      
        #gauss_3s=np.stack([gauss_total,gauss_total, gauss_total], axis=-1).reshape(row,col,3)
        #gauss=gauss.astype(np.uint16)
      noisy = image[middle_part[0]-sli_add_before:middle_part[1]+sli_add_after]+gauss_total
      noisy[noisy>1] = 1
      
      image_3d=np.concatenate([slices_before,noisy,slices_after],axis=0).reshape(1,-1,row,row,1)
      #print(image_3d.shape)  
      #noisy=noisy.astype(np.uint16)
          
     
      return image_3d

def makeGaussian(size, sigma_x=10,sigma_y=10,theta=0,center=None):
    """ Make a square gaussian kernel.

    size is the length of a side of the square
    fwhm is full-width-half-maximum, which
    can be thought of as an effective radius.
    """

    x = np.arange(0, size, 1, float)
    y = x[:,np.newaxis]

    if center is None:
        xo = yo = size // 2
    else:
        xo = center[1]
        yo = center[0]
    
    sigma_x=random.randint(1,3)/2
    sigma_y=random.randint(1,3)/2
    theta=random.randint(0,180)
    amplitude=1#  4*(10e3)

    a = (np.cos(theta)**2)/(2*sigma_x**2) + (np.sin(theta)**2)/(2*sigma_y**2)
    b = -(np.sin(2*theta))/(4*sigma_x**2) + (np.sin(2*theta))/(4*sigma_y**2)
    c = (np.sin(theta)**2)/(2*sigma_x**2) + (np.cos(theta)**2)/(2*sigma_y**2)

    g = amplitude*np.exp( - (a*((x-xo)**2) + 2*b*(x-xo)*(y-yo) 
                            + c*((y-yo)**2)))
    
    return g.ravel().reshape(size, size)

# path_image="X:/Ruben/TESE/New_training_Unet/data_only_pericardium/Cardiac_fat_new/0"
# path_mask="/content/drive/MyDrive/noisy images/0/Mask/ACel/patient_00_00.tif"

# img=cv2.imread(path_image,flags=cv2.IMREAD_ANYDEPTH)
# img_mask=cv2.imread(path_mask,0)

# print(np.unique(img))
# type(img)

# img_with_noise=noisy_gaussian(img, img_mask)
# plt.imshow(img_with_noise,cmap="gray")
# plt.show()
# plt.imshow(img_mask,cmap="gray")
# plt.show()
# path_save=os.path.join("/content/drive/MyDrive/noisy images/noisy",'patient_00_00.tif')
# cv2.imwrite(path_save,img_with_noise)

# PATH ="X:/Ruben/TESE/New_training_Unet/data_only_pericardium/Cardiac_fat_new/4"
# path_to_copy="X:/Ruben/TESE/Data/Dataset_public/RioFatSegm/Organization/teste_calcification"
# list_patients=sorted(os.listdir(PATH+'/Dicom'))
# # path_dicom='X:/Ruben/TESE/New_training_Unet/all_data/OSIC_new/4/Dicom/'
# # path_label='X:/Ruben/TESE/New_training_Unet/all_data/OSIC_new/4/Mask/'
# import glob

# for patient in list_patients:
#     dicom_files= os.path.join(PATH,'Dicom',patient)
#     files=sorted(glob.glob(dicom_files+'/*'))
#     for file in files:
        
#         name_file=os.path.split(file)[-1] #only the name of the image, not the entire path
#         file_mask=os.path.join(PATH,'Mask',patient,name_file)
        
#         img=cv2.imread(file,flags=cv2.IMREAD_ANYDEPTH)
#         img_mask=cv2.imread(file_mask,0)
        
#         path_test_calcification=os.path.join(path_to_copy,"Calcification", patient)
#         isExist = os.path.exists(path_test_calcification)
        
#         if not isExist:                         
#          # Create a new directory because it does not exist 
#          os.makedirs(path_test_calcification)
        
#         print(file)
#         img_with_noise=noisy_gaussian(img/65535., img_mask/255.)
#         #cv2.imwrite(os.path.join(path_test_calcification,name_file),img_with_noise)
       
#         plt.imshow(img_with_noise,cmap='gray')
  