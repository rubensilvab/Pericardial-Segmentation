# -*- coding: utf-8 -*-
"""Registration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uYgBV0wdMku6b786CdOP5hlMkJb8cmty
"""

# from google.colab import drive
# drive.mount('/content/drive', force_remount=True) #this works to conect the drive to the script itself being then able to acess files such as the data.zip

# """Extração dos ficheiros zip"""

# !unzip /content/drive/MyDrive/TESE/RioFatSegm.zip

# import glob
# import cv2
# import matplotlib.pyplot as plt
# from scipy.spatial import ConvexHull
# from PIL import Image, ImageDraw
# # example of converting an image with the Keras API
# # example of saving an image with the Keras API
# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import save_img
# from keras.preprocessing.image import img_to_array
# import numpy as np # linear algebra
# import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# # Input data files are available in the read-only "../input/" directory
# # For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

# import os

# import numpy as np # linear algebra
# import pandas as pd
# import cv2
# from keras.preprocessing.image import img_to_array
# from keras.preprocessing.image import array_to_img
# from keras.preprocessing.image import smart_resize as resize

# """Install Dicom"""

# !pip install pydicom

# """Mudar range HU e normalização"""

# def min_max_norm(x):
#   y = (x -np.min(x)) / (np.max(x) - np.min(x))
#   return y

# def convert_hu(dicom,min,max):
#   dicom_hu = dicom.pixel_array * dicom.RescaleSlope + dicom.RescaleIntercept
#   clipped_hu=np.zeros((512,512))
#   clipped_hu = np.clip(dicom_hu, min,max)
  
#   #for i in range(len(dicom_hu[0,:])):
#    # for l in range(len(dicom_hu[:,0])):
#     #    if dicom_hu[l,i]>max or dicom_hu[l,i]<min :
#      #       clipped_hu[l,i]=min
#       #  else:
#        #     clipped_hu[l,i]=dicom_hu[l,i]
#   y = min_max_norm(clipped_hu)          
#   return clipped_hu

# import pydicom 
# path='/content/RioFatSegm/Dicom _ Treino/ACel/IM-0003-0001_an.dcm'

# from sklearn import preprocessing
# dicom = pydicom.dcmread(path)
# y=convert_hu(dicom,-200,-30)
# dicom_img_path="/content/drive/MyDrive/TESE/RioFat/New/Peri_conv/images"
# os.chdir(dicom_img_path) 
# img_dicom= img_to_array(y)
# save_img('teste_dicom.png', img_dicom)  

# plt.figure(figsize=(20,20))
# plt.subplot(1,2,1)
# plt.imshow(dicom.pixel_array,cmap='gray')
# plt.title('DICOM')
# plt.subplot(1,2,2)
# plt.imshow(y,cmap='gray')
# plt.title('DICOM-FAT_IMAGE')

# """lOAD IMAGENS ANTIGAS"""

# # load numpy array from npy file
# import os

# from numpy import load
# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# mascaras_epi=load('epi_mask_fat.npy')
# mascaras_peri=load('convex_mask.npy')
# fat_images=load('fat_images_fcon.npy')
# dicom_images=load('dicom_images.npy')

# mascaras_epi.shape

# fat_images.shape

# dicom_images.shape

# import matplotlib.pyplot as plt

# plt.figure(figsize=(20,20))
# plt.subplot(1,2,1)
# plt.imshow(dicom_images[50],cmap='gray')
# plt.title('DICOM')
# plt.subplot(1,2,2)
# plt.imshow(fat_images[50],cmap='gray')
# plt.title('FAT_IMAGE')

# """Tentativa com SimpleElastix"""

# !pip install SimpleITK-SimpleElastix

# array_path="/content/drive/MyDrive/TESE/RioFat"
# os.chdir(array_path) 


# !git clone https://github.com/kaspermarstal/SimpleElastix

# array_path="/content/drive/MyDrive/TESE/RioFat/SimpleElastix/Wrapping/Python/Packaging"
# os.chdir(array_path)

# python setup.py install

# !pip install SimpleITK==1.1.0

# import SimpleITK as sitk

# elastixImageFilter = sitk.ElastixImageFilter()
# elastixImageFilter.SetFixedImage(sitk.ReadImage(fat_images[50]))
# elastixImageFilter.SetMovingImage(sitk.ReadImage(dicom_images[50]))
# elastixImageFilter.SetParameterMap(sitk.GetDefaultParameterMap("rigid"))
# elastixImageFilter.Execute()
# sitk.WriteImage(elastixImageFilter.GetResultImage())

# """Tentativa com Image_registration"""

# !pip install image_registration

# from skimage import registration

# file ='/content/RioFatSegm/Fat Images/ACel/IM-0003-0001.BMP'
# img =cv2.imread(file,0)

# flow=registration.optical_flow_tvl1(img, y)

# flow_x=flow[1,:,:]
# flow_y=flow[0,:,:]

# xoff=np.mean(flow_x)
# yoff=np.mean(flow_y)

# from scipy.ndimage import shift

# corrected = shift(y, shift=(xoff,yoff))

# plt.figure(figsize=(20,20))
# plt.subplot(1,3,1)
# plt.imshow(y,cmap='gray')
# plt.title('DICOM')
# plt.subplot(1,3,2)
# plt.imshow(img,cmap='gray')
# plt.title('FAT_IMAGE')
# plt.subplot(1,3,3)
# plt.imshow(corrected,cmap='gray')
# plt.title('FAT_IMAGE_c')

# """SIMPLEITK"""

# !pip install SimpleITK

# import SimpleITK as sitk

# """Fixed Image"""

# file ='/content/RioFatSegm/Fat Images/ACel/IM-0003-0001.BMP'
# img =cv2.imread(file,0)
# img=min_max_norm(img)
# #img=img.astype(np.float32)

# """Moving Image"""

# #!pip install pydicom
# import pydicom 
# path='/content/RioFatSegm/Dicom _ Treino/ACel/IM-0003-0001_an.dcm'
# dicom = pydicom.dcmread(path)
# y=convert_hu(dicom,-200,-30)
# #y=y.astype(np.float32)

# plt.figure(figsize=(20,20))
# plt.subplot(1,2,1)
# plt.imshow(y,cmap='gray')
# plt.title('DICOM-Moving-Image')
# plt.subplot(1,2,2)
# plt.imshow(img,cmap='gray')
# plt.title('FAT_IMAGE- Fixed Image')

# fixed_image = img.astype(np.float32)
# moving_image = y.astype(np.float32)

# np.max(fixed_image)

# # if this is supposed to be a 2D color image [x=20,y=10]

# fixed_image = sitk.GetImageFromArray(img, isVector=True)
# fixed_image2 = sitk.Cast(fixed_image, sitk.sitkVectorFloat32)
# print(moving_image.GetSize())

# moving_image = sitk.GetImageFromArray(y)
# moving_image2 = sitk.Cast(moving_image, sitk.sitkVectorFloat32)
# #print(moving_image.GetSize())
# moving_image2.GetSize()
# sitk.Show(y)

# initial_transform = sitk.CenteredTransformInitializer(fixed_image2, 
#                                                       moving_image2, 
#                                                       sitk.Euler2DTransform(), 
#                                                       sitk.CenteredTransformInitializerFilter.GEOMETRY)

# moving_resampled = sitk.Resample(moving_image, fixed_image, initial_transform, sitk.sitkLinear, 0.0, moving_image.GetPixelID())

# plt.imshow(moving_resempled,cmap='gray')

# """Tentativa com pystackreg


# """

# !pip install pystackreg

# from skimage import io
# from pystackreg import StackReg

# """Fixed image"""

# file ='/content/RioFatSegm/Fat Images/ACel/IM-0003-0001.BMP'
# fixed_image =cv2.imread(file,0)
# #img=min_max_norm(img)
# #img=img.astype(np.float32)

# """moving Image"""

# #IMAGEM USADA PARA REGISTATION
# dicom_img_path="/content/drive/MyDrive/TESE/RioFat/New/Peri_conv/images/teste_dicom.png"
# moving_image =cv2.imread(dicom_img_path,0)

# #IMAGEM DICOM ORIGINAL
# path='/content/RioFatSegm/Dicom _ Treino/ACel/IM-0003-0001_an.dcm'
# dicom = pydicom.dcmread(path)
# dicom=dicom.pixel_array

# """Calculo da matriz de transformação"""

# #Scaled Rotation transformation
# sr = StackReg(StackReg.SCALED_ROTATION)
# tmats = sr.register(fixed_image, moving_image)
# corrected_fat_dicom = sr.transform(moving_image, tmats)
# corrected_dicom = sr.transform(dicom,tmats)

# corrected_dicom.shape

# plt.figure(figsize=(20,20))
# plt.subplot(1,4,1)
# plt.imshow(y,cmap='gray')
# plt.title('DICOM-Moving-Image')
# plt.subplot(1,4,2)
# plt.imshow(img,cmap='gray')
# plt.title('FAT_IMAGE- Fixed Image')
# plt.subplot(1,4,3)
# plt.imshow(corrected_fat_dicom,cmap='gray')
# plt.title('corrected-DICOM FAT')
# plt.subplot(1,4,4)
# plt.imshow(corrected_dicom,cmap='gray')
# plt.title('corrected ORIGINAL DICOM')



# """FAZER LOAD DAS IMAGENS"""

# import os

# from numpy import load
# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# #mascaras_epi=load('epi_mask_fat.npy')
# #mascaras_peri=load('convex_mask.npy')
# fat_images=load('fat_images_fcon.npy')
# dicom_images=load('dicom_images.npy')

# !pip install pystackreg

# """FUNÇÃO PARA CALCULAR MATRIZ DE TRANSFORMAÇÃO COM A LIBRARIA "PYSTACKREG""""

# from skimage import io
# from pystackreg import StackReg

# def regist(fix_img,mov_img):
#   sr = StackReg(StackReg.SCALED_ROTATION)
#   tmats = sr.register(fix_img, mov_img)
#   return tmats

# import os
# import glob
# import cv2
# import matplotlib.pyplot as plt
# import numpy as np

# dmov_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM_FAT"
# files=glob.glob(dmov_path+'/*.png')
# #print(files)

# names=[]

# """PERCORRE TODAS AS IMAGENS DICOM CONVERTIDAS PARA FAT(MOVING IMAGE) E ENCONTRA A RESPETIVA MATRIZ DE TRANSFORMAÇÃO COM AS FAT_IMAGES QUE TEM A LABEL(FIXED IMAGE)"""

# #transformation_matrix=[]
# fat_images_dicom=[]
# n=0
# for file in files:
  
#   #IMAGEM USADA PARA REGISTATION (file)
#   moving_image =cv2.imread(file,0)

#   #IMAGEM FIXA QUE CONTEM A LABEL
#   fixe_image=fat_images[n]
  
#   #CALCULO DA MATRIZ DE TRANSFORMAÇÃO
#   #tmat=regist(fixe_image,moving_image)
  
#   #transformation_matrix.append(list(tmat))
  
#   # GUARDAR NOME E SLICE DO PACIENTE
#   name=file.split('/')
#   name=name[-1]
#   name=name.split('_')
#   ind=str(name[0])+str('_')+str(name[1])

#   fat_images_dicom.append(list(moving_image))
#   names.append(ind)
#   n=n+1

# #transformation_matrix =np.array(transformation_matrix)

# fat_images_dicom=np.array(fat_images_dicom)

# fat_images_dicom.shape

# transformation_matrix.shape

# """FUNÇÃO PARA CORRIGIR ALGUMAS TRANSFORMAÇÕES E ESCOLHER A MATRIZ DE TRANSFORMAÇÃO CORRETA PARA CADA PACIENTE"""

# def correct_matrix_by_patient(patient):
#         if patient=='ACel':
#           n=0
#         elif patient=='AEdu':
#           n=35
#         elif patient=='AMar': 
#           n=112       
#         elif patient=='AFre':
#           n=72
#         elif patient=='AXav':  
#           n=155
#         elif patient=='CLis':    
#           n=256
#         elif patient=='CFer':
#           n=189
#         elif patient=='DLag':
#           n=258
#         elif patient=='DSan':
#           n=295
#         elif patient=='JFul':
#           n=532
#         elif patient=='JMir':
#           n=575
#         elif patient=='MSil':
#           n=681
#         elif patient=='FSiq':
#           n=460
#         elif patient=='ISou':
#           n=516
#         elif patient=='MPai':  
#           n=607
#         elif patient=='VMar':  
#           n=723
#         elif patient=='DSil':   
#           n=362
#         elif patient=='TJes':  
#           n=685
#         elif patient=='EGra':
#           n=377
#         elif patient=='FGas':
#           n=418
#         return n

# corrected_dicom=[]

# new_transformation_matrix=[]

# """SABENDO AGORA AS MATRIZES DE TRANSFORMAÇÃO , APLICAR NAS IMAGENS DICOM ORIGINAIS"""

# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import save_img
# from keras.preprocessing.image import img_to_array
# n=0
# for i in range(len(dicom_images)):

#     sr = StackReg(StackReg.SCALED_ROTATION)
#     #corrected_fat_dicom = sr.transform(moving_image, transformation_matrix[i])
#     patient=names[i][0:4]
#     tmat_p=correct_matrix_by_patient(patient)
    
#     # APLICAR A MATRIZ DE TRANSFORMAÇÃO À IMAGEM DICOM ORIGINAL
#     cor_dcm = sr.transform(dicom_images[i],transformation_matrix[tmat_p])
    
#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM"
#     os.chdir(dicom_img_path) 
#     img_dicom= img_to_array(cor_dcm)
#     save_img(str(names[i])+'_'+str(n)+'_dicom_regist.png', img_dicom)

#     #GUARDAR A MATRIZ DE TRANSFORMAÇÃO ESCOLHIDA PARA O PACIENTE
#     new_transformation_matrix.append(list(transformation_matrix[tmat_p]))
    
#     n=n+1
#     corrected_dicom.append(list(cor_dcm))

# corrected_dicom=np.array(corrected_dicom)

# new_transformation_matrix=np.array(new_transformation_matrix)

# """LOAD ARRAYS"""

# import os
# import glob
# import cv2
# import matplotlib.pyplot as plt
# import numpy as np
# from numpy import load

# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# mascaras_epi=load('epi_mask_fat.npy')
# mascaras_peri=load('convex_mask.npy')
# fat_images=load('fat_images_fcon.npy')
# dicom_images=load('dicom_images.npy')
# fat_images_dicom=load('fat_images_dicom.npy')
# dicom_regists=load('regist_dicom.npy')
# matriz_t=load('new_tmats.npy')

# print(matriz_t[0])

# """RESULTADOS"""

# plt.figure(figsize=(20,20))

# # set the spacing between subplots
# plt.subplots_adjust(left=0.1,
#                     bottom=0.1, 
#                     right=0.9, 
#                     top=0.6, 
#                     wspace=0.1, 
#                     hspace=0.1)
# plt.subplot(2,3,1)
# plt.imshow(dicom_images[226],cmap='gray')
# plt.title('DICOM-Original')
# plt.subplot(2,3,2)
# plt.imshow(fat_images[226],cmap='gray')
# plt.title('FAT_IMAGE- Fixed Image')
# plt.subplot(2,3,3)
# plt.imshow(dicom_regists[226],cmap='gray')
# plt.title('corrected ORIGINAL DICOM')
# plt.subplot(2,3,4)
# plt.imshow(fat_images_dicom[226],cmap='gray')
# plt.title('FAT IMAGES DICOM')
# plt.subplot(2,3,5)
# plt.imshow(mascaras_epi[226],cmap='gray')
# plt.title('MASCARA EPICARDIO')
# plt.subplot(2,3,6)
# plt.imshow(mascaras_peri[226],cmap='gray')
# plt.title('MASCARA PERICARDIO')

# """SAVE ARRAYS"""

# from numpy import save
# #array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# #os.chdir(array_path) 
# #save('regist_dicom.npy', corrected_dicom)
# #save('new_tmats.npy', new_transformation_matrix)
# #save('fat_images_dicom.npy',fat_images_dicom)

# """PROCESSO INVERSO

# PERCORRE TODAS AS IMAGENS DICOM CONVERTIDAS PARA FAT(MOVING IMAGE) E ENCONTRA A RESPETIVA MATRIZ DE TRANSFORMAÇÃO COM AS FAT_IMAGES QUE TEM A LABEL(FIXED IMAGE)
# """



# transformation_matrix=[]
# fat_images_dicom=[]
# n=0
# for file in files:
  
#   #IMAGEM USADA PARA REGISTATION (file)
#    fixe_image =fat_images_dicom[n]

#   #IMAGEM FIXA QUE CONTEM A LABEL
#    moving_image=fat_images[n]
  
#   #CALCULO DA MATRIZ DE TRANSFORMAÇÃO
#   tmat=regist(fixe_image,moving_image)
  
#   transformation_matrix.append(list(tmat))
  
#   # GUARDAR NOME E SLICE DO PACIENTE
#   name=file.split('/')
#   name=name[-1]
#   name=name.split('_')
#   ind=str(name[0])+str('_')+str(name[1])

#   fat_images_dicom.append(list(moving_image))
#   names.append(ind)
#   n=n+1

# transformation_matrix =np.array(transformation_matrix)

# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import save_img
# from keras.preprocessing.image import img_to_array
# n=0
# for i in range(len(dicom_images)):

#     sr = StackReg(StackReg.SCALED_ROTATION)
#     #corrected_fat_dicom = sr.transform(moving_image, transformation_matrix[i])
#     patient=names[i][0:4]
#     tmat_p=correct_matrix_by_patient(patient)
    
#     # APLICAR A MATRIZ DE TRANSFORMAÇÃO À IMAGEM DICOM ORIGINAL
#     cor_dcm = sr.transform(dicom_images[i],transformation_matrix[tmat_p])
    
#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM"
#     os.chdir(dicom_img_path) 
#     img_dicom= img_to_array(cor_dcm)
#     save_img(str(names[i])+'_'+str(n)+'_dicom_regist.png', img_dicom)

#     #GUARDAR A MATRIZ DE TRANSFORMAÇÃO ESCOLHIDA PARA O PACIENTE
#     new_transformation_matrix.append(list(transformation_matrix[tmat_p]))
    
#     n=n+1
#     corrected_dicom.append(list(cor_dcm))



# plt.figure(figsize=(20,20))

# # set the spacing between subplots
# plt.subplots_adjust(left=0.1,
#                     bottom=0.1, 
#                     right=0.9, 
#                     top=0.6, 
#                     wspace=0.1, 
#                     hspace=0.1)
# plt.subplot(2,3,1)
# plt.imshow(dicom_images[178],cmap='gray')
# plt.title('DICOM-Original')
# plt.subplot(2,3,2)
# plt.imshow(fat_images[178],cmap='gray')
# plt.title('FAT_IMAGE- Fixed Image')
# plt.subplot(2,3,3)
# plt.imshow(cor_fat,cmap='gray')
# plt.title('corrected ORIGINAL FAT')
# plt.subplot(2,3,4)
# plt.imshow(fat_images_dicom[756],cmap='gray')
# plt.title('FAT IMAGES DICOM')
# plt.subplot(2,3,5)
# plt.imshow(mascaras_epi[756],cmap='gray')
# plt.title('MASCARA EPICARDIO')
# plt.subplot(2,3,6)
# plt.imshow(mascaras_peri[756],cmap='gray')
# plt.title('MASCARA PERICARDIO')

# """USAR OPEN CV PARA REGISTRATION"""

# import os
# import glob
# import cv2
# import matplotlib.pyplot as plt
# import numpy as np
# from numpy import load

# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# mascaras_epi=load('epi_mask_fat.npy')
# mascaras_peri=load('convex_mask.npy')
# fat_images=load('fat_images_fcon.npy')
# dicom_images=load('dicom_images.npy')
# fat_images_dicom=load('fat_images_dicom.npy')

# """CRIAÇÃO DOS NOMES"""

# import os
# import glob

# dmov_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM_FAT"
# files=glob.glob(dmov_path+'/*.png')
# names=[]
# n=0
# for file in files:
  
#   # GUARDAR NOME E SLICE DO PACIENTE
#   name=file.split('/')
#   name=name[-1]
#   name=name.split('_')
#   ind=str(name[0])+str('_')+str(name[1])

#   names.append(ind)
#   n=n+1

# """Encontrar matriz de transformação da fat image (moving image) para a DICOM(fixed image) através da técnica de cv2(em cima)"""

# import cv2
# import numpy as np

# transformation_matrix=[]

# for i in range(len(dicom_images)):

# # Create ORB detector with 5000 features.
#   orb_detector = cv2.ORB_create(5000)

# # Find keypoints and descriptors.
# # The first arg is the image, second arg is the mask
# # (which is not required in this case). 

# #IMAGEM USADA PARA REGISTATION (file)
#   fixed_image =fat_images_dicom[i]

#   #IMAGEM FIXA QUE CONTEM A LABEL
#   moving_image=fat_images[i]

#   kp1, d1 = orb_detector.detectAndCompute(moving_image, None)
#   kp2, d2 = orb_detector.detectAndCompute(fixed_image, None)

# # Match features between the two images.
# # We create a Brute Force matcher with
# # Hamming distance as measurement mode.
#   matcher = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck = True)

# # Match the two sets of descriptors.
#   matches = matcher.match(d1, d2)

# # Sort matches on the basis of their Hamming distance.
#   matches.sort(key = lambda x: x.distance)

# # Take the top 90 % matches forward.
#   matches = matches[:int(len(matches)*0.9)]
#   no_of_matches = len(matches)

# # Define empty matrices of shape no_of_matches * 2.
#   p1 = np.zeros((no_of_matches, 2))
#   p2 = np.zeros((no_of_matches, 2))

#   for n in range(len(matches)):
#     p1[n, :] = kp1[matches[n].queryIdx].pt
#     p2[n, :] = kp2[matches[n].trainIdx].pt

# # Find the homography matrix.
#   homography, mask = cv2.findHomography(p1, p2, cv2.RANSAC)

#   transformation_matrix.append(homography)

# transformation_matrix=np.array(transformation_matrix)

# transformation_matrix.shape

# """Aplicar matriz de transformação imagem a imagem"""

# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import save_img
# from keras.preprocessing.image import img_to_array
# n=0
# #corrected_fat=[]
# new_epi=[]
# new_peri=[]
# for i in range(len(dicom_images)):

#     #corrected_fat_dicom = sr.transform(moving_image, transformation_matrix[i])
#     patient=names[i][0:4]
    
#     # APLICAR A MATRIZ DE TRANSFORMAÇÃO À IMAGEM DICOM ORIGINAL
    
#     # Use this matrix to transform the
# # colored image wrt the reference image.
#     #cor_fat = cv2.warpPerspective(fat_images[i],
# 		#			transformation_matrix[i], (512, 512))

#     # save the  dicom image 
#     #dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/FAT_CORRIGIDA_CV2"
#     #os.chdir(dicom_img_path) 
#     #img_fat= img_to_array(cor_fat)
#     #save_img(str(names[i])+'_'+str(n)+'_fat_regist.png', img_fat)

#   # Use this matrix to transform the
#   # colored image wrt the reference image.
#     epi_mask = cv2.warpPerspective(mascaras_epi[i],
# 					transformation_matrix[i], (512, 512))

#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/EPI_MASK_CORRIGIDA"
#     os.chdir(dicom_img_path) 
#     img_fat= img_to_array(epi_mask)
#     save_img(str(names[i])+'_'+str(n)+'_epi_regist.png', img_fat)

# # Use this matrix to transform the
#   # colored image wrt the reference image.
#     peri_mask = cv2.warpPerspective(mascaras_peri[i],
# 					transformation_matrix[i], (512, 512))

#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/PERI_MASK_CORRIGIDA"
#     os.chdir(dicom_img_path) 
#     img_fat= img_to_array(peri_mask)
#     save_img(str(names[i])+'_'+str(n)+'_peri_regist.png', img_fat)



#     #GUARDAR A MATRIZ DE TRANSFORMAÇÃO ESCOLHIDA PARA O PACIENTE
#     #new_transformation_matrix.append(list(transformation_matrix[tmat_p]))
    
#     n=n+1
#     corrected_fat.append(list(cor_fat))
#     new_epi.append(list(epi_mask))
#     new_peri.append(list(peri_mask))

# corrected_fat=np.array(corrected_fat)
# new_epi=np.array(new_epi)
# new_peri=np.array(new_peri)

# from numpy import save
# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 
# #save('regist_fat.npy', corrected_fat)
# #save('tmat_cv2.npy', transformation_matrix)
# #save('mask_epi_regist.npy', new_epi)
# #save('mask_peri_regist.npy', new_peri)

# """LOAD"""

# import os
# import glob
# import cv2
# import matplotlib.pyplot as plt
# import numpy as np
# from numpy import load

# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# matriz_transformaçao_all=load('tmat_cv2.npy')

# """Fazer a média da matriz de transformação por paciente"""

# dmov_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM_FAT"
# files=glob.glob(dmov_path+'/*.png')
# names=[]
# t_patient=[]
# t_todos=[]
# slice_passado=1
# n=0
# for file in files:
  
#   # GUARDAR NOME E SLICE DO PACIENTE
#   name=file.split('/')
#   name=name[-1]
#   name=name.split('_')
#   slice_atual=int(name[1])
  
#   ind=str(name[0])+str('_')+str(name[1])
#   names.append(ind)

#   if (slice_atual >= slice_passado) and n!=756:
#     t_patient.append(matriz_transformaçao_all[n])
#     #print('entrou',slice_atual,slice_passado)
  
#   elif (slice_atual >= slice_passado) and n==756:
#     t_patient.append(matriz_transformaçao_all[n])
#     t_patient=np.mean(np.array(t_patient),axis=0)
#     t_todos.append(t_patient)
#     #print('final')
#   else:
#     t_patient=np.mean(np.array(t_patient),axis=0)
#     t_todos.append(t_patient)
#     t_patient=[]
#     t_patient.append(matriz_transformaçao_all[n])
#     #print('entrou append',slice_atual,slice_passado)

#   slice_passado=slice_atual
#   n=n+1

# """CHECK SE COINCIDE"""

# t_todos=np.array(t_todos)

# t_todos.shape

# t_qualquer=np.mean(matriz_transformaçao_all[719:757],axis=0)

# t_todos[19]

# t_qualquer

# matriz_transformaçao_all[0:2]

# """APLICAR MATRIZ DE TRANSFORMAÇÃO(DEPENDENDO DO PACIENTE)"""

# import os
# import glob
# import cv2
# import matplotlib.pyplot as plt
# import numpy as np
# from numpy import load

# array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# os.chdir(array_path) 

# mascaras_epi=load('epi_mask_fat.npy')
# mascaras_peri=load('convex_mask.npy')
# fat_images=load('fat_images_fcon.npy')
# dicom_images=load('dicom_images.npy')
# matriz_transformaçao_p_patient=load('tmat_cv2_p.npy')

# from keras.preprocessing.image import load_img
# from keras.preprocessing.image import save_img
# from keras.preprocessing.image import img_to_array
# n=0
# corrected_fat=[]
# new_epi=[]
# new_peri=[]
# patient_anterior='ACel'
# n_p=0
# for i in range(len(dicom_images)):

#     patient_atual=names[i][0:4]

#     if patient_atual != patient_anterior:
#       n_p=n_p+1
     
    
#     # APLICAR A MATRIZ DE TRANSFORMAÇÃO À IMAGEM DICOM ORIGINAL
    
#     # Use this matrix to transform the

#     #cor_fat = cv2.warpPerspective(fat_images[i],
# 		#		matriz_transformaçao_p_patient[n_p], (512, 512))

#     # save the  dicom image 
#     #dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/FAT_CORRIGIDA_CV2"
#     #os.chdir(dicom_img_path) 
#     #img_fat= img_to_array(cor_fat)
#     #save_img(str(names[i])+'_'+str(n)+'_fat_regist.png', img_fat)
    
#   # Use this matrix to transform the
#   # colored image wrt the reference image.
#     epi_mask = cv2.warpPerspective(mascaras_epi[i],
# 					matriz_transformaçao_p_patient[n_p], (512, 512))

#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/EPI_MASK_train"
#     os.chdir(dicom_img_path) 
#     img_fat= img_to_array(epi_mask)
#     #save_img(str(names[i])+'_'+str(n)+'_epi_regist.png', img_fat)
#     save_img("{:03d}".format(n)+'_dicom.png', img_fat)

# # Use this matrix to transform the
#   # colored image wrt the reference image.
#     peri_mask = cv2.warpPerspective(mascaras_peri[i],
# 					matriz_transformaçao_p_patient[n_p], (512, 512))

#     # save the  dicom image 
#     dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/PERI_MASK_train"
#     os.chdir(dicom_img_path) 
#     img_fat= img_to_array(peri_mask)
#     #save_img(str(names[i])+'_'+str(n)+'_peri_regist.png', img_fat)
#     save_img("{:03d}".format(n)+'_dicom.png', img_fat)

#   # save the  dicom image 
#     #dicom_img_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM_train"
#     #os.chdir(dicom_img_path)
#     #dicom_img=dicom_images[i] 
#     #img_fat= img_to_array(dicom_img)
#     #save_img("{:03d}".format(n)+'_dicom.png', img_fat)

 
 
 
#     print(names[i],n_p)
#    #Guardar paciente anterior

#     patient_anterior=patient_atual


#     #GUARDAR A MATRIZ DE TRANSFORMAÇÃO ESCOLHIDA PARA O PACIENTE
    
#     n=n+1
#     #corrected_fat.append(list(cor_fat))
#     #new_epi.append(list(epi_mask))
#     #new_peri.append(list(peri_mask))

# corrected_fat=np.array(corrected_fat)
# new_epi=np.array(new_epi)
# new_peri=np.array(new_peri)

# """Save"""

# from numpy import save
# #array_path="/content/drive/MyDrive/TESE/RioFat/arrays"
# #os.chdir(array_path) 
# #save('regist_fat.npy', corrected_fat)
# #save('tmat_cv2_p.npy', t_todos)
# #save('mask_epi_regist.npy', new_epi)
# #save('mask_peri_regist.npy', new_peri)

"""LOAD"""

import os
import glob
import cv2
import matplotlib.pyplot as plt
import numpy as np
from numpy import load

array_path="C:/Users/RubenSilva/Desktop/TESE/Data/arrays"
os.chdir(array_path) 

mascaras_epi=load('mask_epi_regist.npy')
mascaras_peri=load('mask_peri_regist.npy')
fat_images=load('fat_images_fcon.npy')
dicom_images=load('dicom_images.npy')
fat_images_dicom=load('fat_images_dicom.npy')
fat_images_regist=load('regist_fat.npy')
matriz_transformaçao_p_patient=load('tmat_cv2_p.npy')

plt.figure(figsize=(20,20))

# set the spacing between subplots
plt.subplots_adjust(left=0.1,
                    bottom=0.1, 
                    right=0.9, 
                    top=0.6, 
                    wspace=0.1, 
                    hspace=0.1)
plt.subplot(2,3,1)
plt.imshow(dicom_images[750],cmap='gray')
plt.title('DICOM-Original')
plt.subplot(2,3,2)
plt.imshow(fat_images[750],cmap='gray')
plt.title('FAT_IMAGE- Fixed Image')
plt.subplot(2,3,5)
plt.imshow(fat_images_regist[750],cmap='gray')
plt.title('corrected ORIGINAL FAT')
plt.subplot(2,3,4)
plt.imshow(fat_images_dicom[750],cmap='gray')
plt.title('FAT IMAGES DICOM')
plt.subplot(2,3,6)
plt.imshow(mascaras_epi[750],cmap='gray')
plt.title('MASCARA EPICARDIO')
plt.subplot(2,3,3)
plt.imshow(mascaras_peri[750],cmap='gray')
plt.title('MASCARA PERICARDIO')

"""CRIAR NRRD FILES (CADA PACIENTE TEM (X,Y,SLICES))"""

import os
import glob
import cv2
import matplotlib.pyplot as plt
import numpy as np
from numpy import load

dmov_path="/content/drive/MyDrive/TESE/RioFat/Registration/DICOM_FAT"
files=glob.glob(dmov_path+'/*.png')

names=[]
nomes=[]

dicom_patient=[]
epi_patient=[]
peri_patient=[]

dicom_global=[]
epi_global=[]
peri_global=[]

slice_passado=1
n=0
for file in files:
  
  # GUARDAR NOME E SLICE DO PACIENTE
  name=file.split('/')
  name=name[-1]
  name=name.split('_')
  slice_atual=int(name[1])
  
  ind=str(name[0])+str('_')+str(name[1])
  names.append(ind)
  nomes.append(str(name[0]))

  if (slice_atual >= slice_passado) and n!=756:
    
    dicom_patient.append(dicom_images[n])
    epi_patient.append(mascaras_epi[n])
    peri_patient.append(mascaras_peri[n])

    print('entrou',slice_atual,slice_passado,str(name[0]))
  
  elif (slice_atual >= slice_passado) and n==756:
     
     #Adicionar ultimo slice de todos
    dicom_patient.append(dicom_images[n])
    epi_patient.append(mascaras_epi[n])
    peri_patient.append(mascaras_peri[n])
    
    # fazer append de todas as imagens do ultimo paciente à matriz global
    dicom_global.append(np.array(dicom_patient))
    epi_global.append(np.array(epi_patient))
    peri_global.append(np.array(peri_patient))
    
    print('final')

  else:
    # fazer append de todas as imagens de um paciente à matriz global
    dicom_global.append(np.array(dicom_patient))
    epi_global.append(np.array(epi_patient))
    peri_global.append(np.array(peri_patient))
    
    # esvaziar para colocar novo paciente
    dicom_patient=[]
    epi_patient=[]
    peri_patient=[]

    # Adicionar primeiro slice do novo paciente
    dicom_patient.append(dicom_images[n])
    epi_patient.append(mascaras_epi[n])
    peri_patient.append(mascaras_peri[n])
    
    print('entrou append',slice_atual,slice_passado)

  slice_passado=slice_atual
  n=n+1

"""Função para fazer reshape de acordo com o 3D Slicer """

def reshape_nrrd(nrrd):
  for i in range(len(nrrd)):
    nrrd[i]=nrrd[i][::-1]
  nrrd=np.array(nrrd)
  for i in range(nrrd.shape[0]):
    nrrd[i]=np.transpose(nrrd[i],(2,1,0))  
  return nrrd

dicom_global=reshape_nrrd(dicom_global)
epi_global=reshape_nrrd(epi_global)
peri_global=reshape_nrrd(peri_global)

dicom_global[2].shape

plt.imshow(dicom_global[0][:,:,33],cmap='gray')

"""WRITE NRRD"""

nomes_nrrd = set(nomes)
nomes_nrrd=list(nomes_nrrd)

nomes_nrrd.sort()
print(nomes_nrrd)

!pip install pynrrd

import nrrd

for i in range(len(nomes_nrrd)):

   # Save the NRRD object with the correct index order
    path="/content/drive/MyDrive/TESE/RioFat/NRRD/DICOM"
    os.chdir(path) 

    nrrd.write(str(nomes_nrrd[i])+'_'+'dicom.nrrd', dicom_global[i])

    path="/content/drive/MyDrive/TESE/RioFat/NRRD/EPI_MASK"
    os.chdir(path) 
    
    nrrd.write(str(nomes_nrrd[i])+'_'+'epi.nrrd', epi_global[i])

    path="/content/drive/MyDrive/TESE/RioFat/NRRD/PERI_MASK"
    os.chdir(path) 
    
    nrrd.write(str(nomes_nrrd[i])+'_'+'peri.nrrd', peri_global[i])

"""TESTE READ"""

path="C:/Users/RubenSilva/Desktop/TESE/Data/NRRD/DICOM/ACel_dicom.nrrd"
import nrrd
# Read the data back from file
readdata, header = nrrd.read(path)
print(readdata.shape)
print(header)

import matplotlib.pyplot as plt

plt.figure(figsize=(20,20))

# set the spacing between subplots
plt.subplots_adjust(left=0.1,
                    bottom=0.1, 
                    right=0.9, 
                    top=0.6, 
                    wspace=0.1, 
                    hspace=0.1)
plt.subplot(2,3,1)
plt.imshow(readdata[:,:,0],cmap='gray')
plt.title('0')
plt.subplot(2,3,2)
plt.imshow(readdata[:,:,5],cmap='gray')
plt.title('5')
plt.subplot(2,3,5)
plt.imshow(readdata[:,:,7],cmap='gray')
plt.title('7')
plt.subplot(2,3,4)
plt.imshow(readdata[:,:,10],cmap='gray')
plt.title('10')
plt.subplot(2,3,6)
plt.imshow(readdata[:,:,11],cmap='gray')
plt.title('11')
plt.subplot(2,3,3)
plt.imshow(readdata[:,:,33],cmap='gray')
plt.title('33')